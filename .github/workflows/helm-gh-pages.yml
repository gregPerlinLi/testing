name: Publish Helm Charts to Pages

on:
  push:
    branches: [ main ]
    paths:
      - '*/Chart.yaml'
      - '*/values.yaml'
      - '*/templates/**'
      - '*/charts/**'
      - '.github/workflows/helm-gh-pages.yml'
      - 'Chart.yaml'
      - 'values.yaml'
      - 'templates/**'
      - 'charts/**'
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: gh-pages
  cancel-in-progress: false

jobs:
  release:
    runs-on: ubuntu-latest
    env:
      HELM_GPG_PRIVATE_KEY: ${{ secrets.HELM_GPG_PRIVATE_KEY }}
      HELM_GPG_PASSPHRASE: ${{ secrets.HELM_GPG_PASSPHRASE }}
    steps:
      - name: Checkout source
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Checkout existing gh-pages (if any)
        id: pages
        uses: actions/checkout@v5
        continue-on-error: true
        with:
          ref: gh-pages
          path: gh-pages
          fetch-depth: 0

      - name: Set up Helm
        uses: azure/setup-helm@v4

      - name: Import GPG signing key (optional)
        if: ${{ env.HELM_GPG_PRIVATE_KEY != '' }}
        env:
          HELM_GPG_PRIVATE_KEY: ${{ secrets.HELM_GPG_PRIVATE_KEY }}
          HELM_GPG_PASSPHRASE: ${{ secrets.HELM_GPG_PASSPHRASE }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p ~/.gnupg
          chmod 700 ~/.gnupg
          printf "%s" "$HELM_GPG_PRIVATE_KEY" | gpg --batch --import
          gpg --list-secret-keys --keyid-format=long
          KEY_ID=$(gpg --list-secret-keys --with-colons | awk -F: '/^sec/{print $5; exit}')
          echo "KEY_ID=$KEY_ID" >> "$GITHUB_ENV"
          # Create pubring.gpg for Helm (Helm defaults to this keyring path)
          gpg --export > ~/.gnupg/pubring.gpg
          echo "pinentry-mode loopback" >> ~/.gnupg/gpg.conf
          echo "allow-loopback-pinentry" >> ~/.gnupg/gpg-agent.conf
          gpgconf --kill gpg-agent || true
          # Warm up gpg-agent cache if passphrase is provided
          if [ -n "${HELM_GPG_PASSPHRASE:-}" ]; then
            echo test | gpg --batch --yes --pinentry-mode loopback --passphrase "$HELM_GPG_PASSPHRASE" -u "$KEY_ID" -s >/dev/null 2>&1 || true
          fi

      - name: Package charts and build index
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p repo
          # Bring forward existing repo content (index/tgz) if gh-pages exists
          if [ -d gh-pages ]; then
            shopt -s dotglob nullglob
            cp -a gh-pages/* repo/ || true
            shopt -u dotglob nullglob
          fi
          # Find top-level charts (exclude subcharts)
          mapfile -t charts < <(find . -maxdepth 3 -type f -name Chart.yaml \
            -not -path "./gh-pages/*" -not -path "./.git/*" -not -path "./.github/*" -not -path "*/charts/*")
          if [ "${#charts[@]}" -eq 0 ]; then
            echo "No charts found."
          else
            for chart in "${charts[@]}"; do
              chart_dir="$(dirname "$chart")"
              echo "Packaging $chart_dir"
              helm dependency build "$chart_dir" || true
              helm lint "$chart_dir" || true
              if [ -n "${KEY_ID:-}" ]; then
                echo "Signing with GPG key $KEY_ID"
                helm package "$chart_dir" --destination repo --sign --key "$KEY_ID" --keyring ~/.gnupg/pubring.gpg
              else
                helm package "$chart_dir" --destination repo
              fi
            done
          fi
          # Build or merge index.yaml
          REPO_URL="https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}"
          if [ -f repo/index.yaml ]; then
            cp repo/index.yaml repo/_old-index.yaml
            helm repo index repo --url "$REPO_URL" --merge repo/_old-index.yaml
            rm -f repo/_old-index.yaml
          else
            helm repo index repo --url "$REPO_URL"
          fi

      - name: Publish to gh-pages
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_branch: gh-pages
          publish_dir: repo
